	.TITLE	PINTER
	.RADIX	16
	.ASECT
	.SBTTL************************
	.SBTTL*
	.SBTTL*PROGRAMMER; S CALFEE
	.SBTTL*
	.SBTTL*CHECKER
	.SBTTL*
	.SBTTL************************
;
;DATE INITIATED: 4/20/78
;PROJECT CHARGE #: 20000
;DISK#: 20
;HARDWARE REQUIREMENTS: M6800 MICROPROCESSOR
;			I/O DEPENDENCIES ARE  HANDLED BY THE OPERATING SYSTEM
;
;
;
;MEMORY REQUIREMENTS:
;
;
;
;
;
;INTERRUPT REQUIREMENTS:
;			REQUIRED BY THE OPERATING SYSTEM
;			THE FREQUENCY IS NOT CRUCIAL, BUT
;			INTERRUPTS ARE NEEDED FOR TIMING
;
;
;ASSEMBLY COMMAND STRING: R MAC68
;			  *DK1:PINTER,LP:=DK1:PINTER/C
;
;
;
;LINK COMMAND STRING: R LINKM
;		      *MT:/L=DK1:PINTER
;
;
;
;PROGRAM DISCRIPTION
; PINBOL PSEUDO MACHINE INTERPRETER
; MULTI-TASKING
; REENTRANT
;
;
;SAMPLE INTERPRETED INSTRUCTION
;
;	PPPPPSSS
;	XXXXXXXX
;
;	P IS THE OP-CODE FIELD
;	S IS THE SOURCE FIELD
;
;		0 = SOLENOIDS
;		1 = SWITCH INPUT (READS IN UNBOUNCED SWITCHES)
;		2 = LIGHTS
;		3 = FLAGS
;		4 = SWITCH OUTPUT (STARTS ANOTHER TASK)
;		5 = COUNTERS AND METERS
;		6 = SOUNDS AND SCORES
;		7 = USE THE COUNTER AS A SOURCE POINTER
;		    IF THE INDIRECTION IS USED, THE FORMAT OF THE
;		    COUNTER IS
;		    UUUUUSSS - U MEANS UNUSED
;		    XXXXXXXX
;
;	X IS THE SOURCE DATA OFFSET INDEX
;
;
;A TASK CONTROL BLOCK TCB IS ALWAYS ON SOME QUEUE
;FORMAT:
;	1 BYTE LINK TO NEXT TCB ON QUEUE
;	1 BYTE COUNTER FOR DELAYS
;	2 BYTES OF INTERPRETED PC
;	1 BYTE OF SOFTWARE STACK POINTER
;	MAXSP*2 BYTES OF STACK
;
;
;
;
;
;PINBALL INTERPRETER BASE PAGE UTILIZATION
;
	.=70
ACTTSK:	.BLKB	1		;NUMBER OF ACTIVE TASKS
ACTCB:	.BLKB	2		;ACTIVE TASK QUEUE HEAD
FRETCB:	.BLKB	2		;FREE TASK QUEUE HEAD
DELTCB:	.BLKB	2		;DELAY TASK QUEUE HEAD CELL
SNDTCB: .BLKB	2		;WAITING ON A SOUND QUEUE
SWIND:	.BLKB	2		;CURRENT SWITCH SCAN INDEX
SWSAV:	.BLKB	1		;CURRENT 8 SWITCHES SAVED
SKIPFL:	.BLKB	1		;SKIP FLAG 0 MEANS DON'T SKIP
CLRAREA	=.			;ZERO TO HERE FROM ACTTSK ON POWER-UP
SWSTAT: .BLKB	1		;FLAG FOR SWITCH LOOP
TEMPX:	.BLKB	2		;TEMPORARY USED UNDER INTERRUPTS
TEMPX2:	.BLKB	2		;TEMPORARY USED UNDER INTERRUPTS
SNDTMP:	.BLKB	2		;TEMP USED BY INTERRUPTS
TEMP:				;TEMPORARY NOT USED BY INTERRUPTS=POINTX
POINTX: .BLKB	2		;ARRAY POINTER
BMASK:	.BLKB	1		;MASK FOR A BIT
CNTMTR: .BLKB	16.		;COUNTER ALLOCATION
;
;PINBALL INTERPRETER EQUATES
;
;TCB
LINK	=0			;THREAD TO OTHER TCB
DELAY	=1			;DELAY COUNTER
PPC	=2			;CURRENT TASK PC
SP	=4			;CURRENT TASK SUBROUTINE STACK
STK	=5			;SUBROUTINE STACK
INSTK	=STK-2			;INDEX TRICK
LMDEL	=10.			;LAMP MODE DELAY VALUE
LMFLG	=9.			;LAMP MODE FLAG IS BIT 7=1
;
;SYSTEM EQUATES
;
MAXSP	=3			;MAXIMUM NUMBER OF SUBROUTINE LEVELS
MAXTSK	=6			;MAXIMUM NUMBER OF TASKS IN THE SYSTEM
TLTOFF	=6			;TILT SWITCH OFFSET
BTILT	=128.			;TITLE BIT
BATRT	=64.			;ATTRACT BIT
BNEXT	=16.			;NEXT PLAYER STARTED BIT
TCBS:	.BLKB	STK+<MAXSP*2>*MAXTSK	;ALLOCTE TCB RAM
RAMTS2:	.BLKB	1		;RAM TEST CELL

;
;OPERATING SYSTEM LINKAGE
;
	.GLOBL	START,TIMER	;ENTRY POINTS
	.GLOBL	MINC,SCRE	;ENTRY PTS
	.GLOBL	SNDQUE		;ENTRY PT
	.GLOBL	NEXTPL		;EXTERNAL REFERENCES
	.GLOBL	TOOS		;OS SWITCHES
	.GLOBL	INDEX
	.GLOBL	OPTION
;
;O.S. BASE PAGE EXTERNAL REFERENCES
;
	.GLOBL	NEWSWT,SWTCNT	;DE BOUNCED SWITCH WORDS-#OF SWITCHES
	.GLOBL	SOLENOIDS	;3 BYTES TO REQUEST SOLENOIDS
	.GLOBL	SWTIN		;HARDWARE SWITCH ADDRESS
	.GLOBL	LIGHTS		;LAMP RAM
	.GLOBL	FLAGS		;FLAG RAM
	.GLOBL	SNDRAM		;SOUND REQUEST #'S
	.GLOBL	BATTERY		;BATTERY BACK UP ADDRESS
	.GLOBL	RAMTS2		;RAM VERIFICATION CELL
;
;SYSTEM PARAMETER LINKAGES
;
	.GLOBL	UVECTOR
	.GLOBL	USTAT		;STATISTICS ROUTINE FOR WHITE WOOD
	.PAGE

	.=3000
;
;PINBALL OPCODE DECODE VECTORS
;
;1 BYTE OP-CODE
VECTAB:
	.WORD	BREAK
	.WORD	DONE
	.WORD	RETURN
	.WORD	NEXTBALL	;OS-SUBROUTINE
	.WORD	NOOP		;NO-OP?
IGRPON	=.-VECTAB/2
	.WORD	GRPON		;ACTUALLY 9 BYTE INSTRUCTIONS
IGRPOF	=.-VECTAB/2
	.WORD	GRPOFF		;BUT DON'T AUTO FETCH THE OPERANDS
;
;2 BYTE OP-CODES
;
TWOOPS	=.-VECTAB/2
ISIF	=.-VECTAB/2
	.WORD	SIF
ISIT	=.-VECTAB/2
	.WORD	SIT
	.WORD	SETF
	.WORD	SETT
	.WORD	LOCKO
	.WORD	LAMPMD		;LAMP MODE
ISPEC	=.-VECTAB/2
	.WORD	JUMP
	.WORD	CALL
	.WORD	DELQ
	.WORD	SOUND
	.WORD	WAITFF
	.WORD	INCCNT
	.WORD	DECCNT
;3 BYTE OR MORE OP-CODES
THREOP  =.-VECTAB/2
	.WORD	SCOUNT
INCNT	=.-VECTAB/2
	.WORD	CNTEQ
	.WORD	CNTNE
MAXOP	=.-VECTAB		;LARGEST OP-CODE TIMES 2
;
;LINKAGE EQUATES
;
BYTEOP	=5		;OPERANDS ARE BYTES
CNTOP	=5		;COUNTER OP-CODE
SNDSRC  =6		;SOUND IS SOURCE
SWTOP	=1
	.PAGE
;
;DATA POINTER TABLE
;
DATPTR:	.WORD	SOLENOIDS
	.WORD	SWTIN
	.WORD	LIGHTS
	.WORD	FLAGS
	.WORD	NEWSWT
	.WORD	CNTMTR
	.WORD	SNDRAM
	.WORD	CNTMTR
	.WORD	BATTERY-10
	.WORD	OPTION
	.PAGE
	.SBTTL	START
;*************************
;*
;* START MULTI-TASKING
;* INTERPRETER
;*
;*************************
;
;DESCRIPTION:	1) ABORTS ALL TASKS AND PLACES THEM ON THE FRETCB QUEUE
;		2) STARTS SWITCH SCAN TO START TASKS
;
;REGISTERS:
;	IN:	NO REQUIREMENT
;
;	OUT:	ALL DESTROYED
;
;STACK USE:	5 BYTES FOR 2 SUBROUTINE CALLS
;
;
;BASE PAGE USE:	TASKING VARIABLES AND TEMPS ONLY
;
;
ISTART:	SEI			;INTERRUPTS OFF
	LDX	I,CLRAREA-ACTTSK	;POINT TO AREA TO INITIALIZE
20$:	CLR	X,ACTTSK-1
	DEX
	BNE	20$		;NOT DONE
	CLI			;INTERRUPTS ON
	LDAA	I,MAXTSK
	STAA	D,TEMP		;SET A COUNTER
	LDX	I,TCBS		;FIRST TCB
40$:	LDAA	I,FRETCB-LINK+1	;QUEUE HEAD CELL
	JSR	QINSERT		;ADD X TO THE FRETCB QUEUE
	CLR	X,SP		;INIT SP
	CLR	X,LMFLG		;CLEAR MODE FLAG
	LDAA	I,STK+<MAXSP*2>
	JSR	INDEX		;POINT AT THE NEXT TCB
	DEC	E,TEMP		;COUNT THOSE TCB'S
	BNE	40$		;NOT DONE
;
;ALL TASKS ARE FREE START PINBALL SCANS
;
	JMP	STASK
;
;INCREMENT INTERPRETED PC X IS DESTROYED
;
INCRPC:	LDX	D,ACTCB
	INC	X,PPC+1		;INCR LOW PC
	BNE	20$
	INC	X,PPC		;INCR HIGH PC
20$:	RTS
	.PAGE
	.SBTTL	MAIN INTERPRETER LOOP
;******************************
;*
;**MAIN OP-CODE DE-CODE LOOP
;*
;******************************
;
;DESCRIPTION:	THIS ROUTINE IS ENTERED WHEN A TASK IS READY,
;		IT FETCHES INTERPRETER OP-CODES, FORMS THE 
;		DATA POINTER AND ENTERS THE REQUESTED OPCODE
;		ROUTINE
;
;
;
;
;REGISTERS:	
;	IN:	REQUIRES ACTCB TO BE POINTING AT A TCB
;
;	OUT:	ALL DESTROYED
;
;
;
;
;
;
;STACK USE:	MAXIMUM OF 8 BYTES
;
;
;
;
;
;BASE PAGE USE:	ALL THAT IS DEFINED IN THIS PROGRAM
;
;
;
;
;
OPLOOP:	LDX	D,ACTCB		;TASK POINTER
	TST	X,LMFLG		;LAMP MODE?
	BPL	20$		;NO
	LDX	I,LAMPLP	;RE-ENTRY PT.
	JMP	GODOIT		;CALL LAMP MODE
20$:	LDX	X,PPC		;GET PROGRAM POINTER
	LDAB	X,1		;GET PARAM 1
	LDAA	X,0		;GET OP-CODE
	PSHA			;SAVE OP-CODE
	LSRA
	LSRA			;GET JUST OP-CODE
	LSRA
	BSR	INCRPC
	CMPA	I,TWOOPS	;TEST IF 2 BYTE OP-CODE
	BLT	40$		;NO 1 BYTE
	BSR	INCRPC		;GUESS 2 BYTE OP-CODE
40$:	TST	E,SKIPFL	;ARE WE SKIPPING
	BEQ	80$		;NO
	CMPA	I,ISIF		;IS IT A SKIP IF FALSE INST?
	BEQ	70$		;YES, THEN CONTINUE SKIP
	CMPA	I,ISIT		;SKIP IF TRUE INST?
	BEQ	70$		;YES, CONTINUE SKIPPING
;
;MOVE PC OVER GRPON, GRPOFF AND SET INSTRUCTIONS
;
	CMPA	I,THREOP	;3 BYTE INST
	BLT	50$
	BSR	INCRPC		;SHIP 3RD BYTE
	CMPA	I,INCNT		;SKIP INSTRUCTION?
	BGE	70$		;CONTINUE SKIP ON 3 BYTE INST
50$:	CMPA	I,IGRPON
	BEQ	55$
	CMPA	I,IGRPOFF
	BNE	60$		;NOT A GROUP INSTR.
55$:	LDX	D,ACTCB
	LDAA	I,8		;SKIP 8 BYTES
	ADDA	X,PPC+1
	STAA	X,PPC+1		;ADD TO LOW PC
	BCC	60$
	INC	X,PPC		;CARRY TO HIGH PC
60$:	CLR	E,SKIPFL	;TERMINATE THE SKIP
70$:	PULA			;CLEAN STACK
	BRA	OPLOOP		;GET THE NEXT INSTRUCTION
80$:	PULA			;GET OP-CODE
	PSHB			;SAVE PARAMETER 1
	STAB	D,TEMP		;AGAIN
	TAB 			;B=OP-CODE
INDIREC:ANDA	I,7		;MASK TO ADDRESSING MODE
	CMPA	I,CNTOP		;COUNTER?
	BNE	10$		;NO
	PSHA
	LDAA	D,TEMP		;OFFSET
	CMPA	I,16.		;METER?
	PULA			;DOESN'T OFFSET PC
	BLT	10$		;NO, COUNTER
	LDAA	I,8.		;METER PTR
10$:	CMPA	I,SWTOP		;SWITCH?
	BNE	20$
	PSHA
	LDAA	D,TEMP		;OFFSET
	CMPA	I,64.		;OPTION?
	PULA
	BLT	20$		;NO
	LDAA	I,9.		;OPTION PTR
20$:
	ASLA
	LDX	I,DATPTR
	BSR 	LINDEX		;POINT TO DATA ARRAY
	TBA
	ANDA	I,7		;TEST ADDRESSING MODE
	CMPA	I,BYTEOP	;FULL BYTE OPERAND?
	BGE	NOTABIT		;POINT AT A WORD OR INDIRECT
	TBA
	LSRA
	LSRA			;GET OP-CODE
	LSRA
	CMPA	I,TWOOPS
	BLT	COMPT		;1 BYTE OP-CODES
;
;POINT AT A BIT
;
	PULA
	PSHA			;GET BIT NUMBER
	LSRA
	LSRA
	LSRA
	BSR	TINDEX		;POINT AT WORD IN THE ARRAY
	PULA
	PSHA
	ANDA	I,7		;GET BIT NUMBER
	STAA	D,TEMP
	CLRA
	SEC
30$:	ROLA			;SHIFT IN MASK
	DEC	E,TEMP		;COUNT BITS
	BPL 	30$		;CONTINUE SHIFT
	BRA	COMPT
;
;DETERINE IF AN INDIRECT OP-CODE
;
NOTABIT:			;B=OP-CODE
				;TEST IF INDIRECT MODE
	CMPA 	I,7
	BNE	WORDPT		;NO-WHOLE WORD
	TBA			;A=OP-CODE
	LSRA
	LSRA			;GET 5 BIT OP-CODE
	LSRA
	CMPA	I,ISPEC		;TEST IF A SPECIAL INSTRUCTION
	BGE	WORDPT		;YES, NO INDIRECT ALLOWED
	CMPA	I,TWOOPS
	BLT	WORDPT		;NO INDIRECT ON 1 BYTE OP-CODES
	PULA			;GET PARAM ON STACK
	BSR	TINDEX		;POINT AT COUNT WORD
	LDAA	X,1		;GET NEW PARM 1
	PSHA
	LDAA	X,0		;GET NEW PARAM 1
	ANDA	I,3
	ANDB	I,0F8		;FORM A NEW INSTRUCTIONS
	ABA
	TAB			;B=NEW OP-CODE
	BRA	INDIREC		;DO THE LOOP AGAIN
;
;POINT AT A DATA WORD
;
WORDPT:	PULA	
	PSHA			;GET AND SAVE WORD NUMBER
	BSR	TINDEX		;BUILD WORD POINTER INDEX
	LDAA	X,0		;FETCH THE WORD
COMPT:	STX	D,POINTX	;SAVE DATA INDEX
	STAA	D,BMASK		;SAVE INDEXED DATA
	TBA			;A=OPCODE
	ANDB	I,7
	LSRA
	LSRA			;GET 5 BIT OP-CODE
	ANDA	I,3E		;TIMES 2
	CMPA	I,MAXOP
	BGE	BADCNT		;ILLEGAL OP-CODE
	LDX	I,VECTAB
	BSR 	LINDEX		;GET SUBR ADDR
	PULA			;GET PARAM 1
;
;CALL AN INSTRUCTION OPERATION SUBROUTINE
;
;	A=BYTE FOLLOWING THE OP-CODE
;	B=LOW 3 BITS OF OP-CODE (OPERAND FIELD)
;	POINTX=POINTS AT THE OPERAND ARRAYS
;	BMASK=BYTE OF ARRAY
;	      OR A BIT MASK FOR BIT ARRAYS
;
;
;
GODOIT:	JSR	X,0		;GO TO A SUBROUTINE
	JMP	OPLOOP		;CONTINUE NOW
	.PAGE
	.SBTTL	INDEXING
;
;BUILD A TRUE INDEX AND LOAD X
;
LINDEX:	BSR	TINDEX
	LDX	X,0		;DO FIRST LOAD
	RTS
;
;BUILD A TRUE INDEX
;X=BASE PTR A=OFFSET
TINDEX:	JMP	INDEX		;GO TO PINBL TO INDEX
	.PAGE
	.SBTTL	TURN ON/OFF GROUPS OF OBJECT
;
;TURN A WHOLE GROUP ON
;
GRPON:	CLRA			;ON FLAG
TONOFF:	CMPB	I,BYTEOP	;LEGAL?
	BGE	BADCNT
	LDAB	I,8.
	STAB	D,BMASK		;SET COUNTER
20$:	LDX	D,ACTCB
	LDX	X,PPC		;GET PC FOR NEXT BYTE
	LDAB	X,0		;GET NEXT BYTE
	LDX	D,POINTX	;POINT INTO TABLE
	SEI
	TSTA			;TEST FLAG
	BNE	40$		;CLEARING
	ORAB	X,0		;ADD BITS
	BRA	50$
40$:	COMB
	ANDB	X,0		;DELETE BITS
50$:	STAB	X,0
	CLI
	INX
	STX	D,POINTX	;NEW INDEX
	JSR	INCRPC		;BUMP PC POINTER
	DEC	E,BMASK		;COUNT LOOP
	BNE	20$		;NOT DONE
NOOP:	RTS
;
;TURN A WHOLE GROUP OFF
;
GRPOFF:	LDAA	I,1		;OFF FLAG
	BRA	TONOFF		;GO TO COMMON ROUTINE
	.SBTTL	MISC
;
;MISCELLANEOUS ROUTINES
;
BADCNT:
BREAK:	SWI			;BREAK TO MONITOR
RETURN: TSTA
	BNE	BADCNT
	LDX	D,ACTCB		;GO TO ASSEMBLY LANGUAGE
	LDX	X,PPC		;GET PC
	JMP	X,0		;GO TO USER - WILL RETURN TO OPLOOP
;
;ROUTINE TO CALL OS TO STEP PLAYERS
;
NEXTBALL:
	INS
	INS			;POP STACK
	JSR	NEXTPL		;GO TO O.S.
	SEI
	NOP
	LDAA	D,FLAGS+7	;GET COMMUN. FLAGS
	BITA	I,40		;TEST ATTRACT FLAG
	BNE	40$
	ORAA	I,10		;SET NEXT PLAYER FLAG
	STAA	D,FLAGS+7
	JMP	RESTART		;ABORT TASKS
40$:	JMP	START		;START ATTRACT MODE
	.SBTTL	SOUND AND SCORE
	.PAGE
	.SBTTL	HANDLE COUNTERS AND METERS
;
;SET COUNTER OR METER
;
SCOUNT:	
	PSHA			;SAVE HIGH 8 BITS
	TBA
	ASLA			;COUNTER INDEX
SCOK:	LDX	D,ACTCB
	LDX	X,PPC		;GET PC
	LDAB	X,0		;GET NEXT BYTE
	LDX	I,CNTMTR
	BSR	TINDEX		;POINT X TO COUNTER
	STAB	X,1		;SAVE LOW VALUE
	PULA
	STAA	X,0		;SAVE HIGH VALUE
	JMP	INCRPC		;BUMP PAST THE VALUE, RETURN
;
;INCREMENT COUNTER OR METER
;COUNTERS ARE 16 BITS WIDE
;METERS ARE THE LOW 4 BITS OF A RAM
;
;
INCCNT:	CMPB	I,CNTOP
	BNE	BADCNT		;ERROR IN PROGRAM!
	LDX	D,POINTX	;GET INDEX
	CMPA	I,16.
	BGE	INCMTR		;DO A METER INCR
	INC 	X,1		;INCR COUNTER
	BNE	20$
	INC	X,0		;CARRY
20$:
	RTS
;
;THE INTERRUPT SYSTEM ENTERS HERE
;TO INCREMENT A METER
;A=METER OFFSET
IMINC:	LDX	I,BATTERY	;ADD B TO METER
	BSR	TINDEX		;POINT AT METER
INCMTR:	LDAB	I,1		;INCR AMOUNT
INCDEC:
	LDAA	I,6
ISCRE:	SEI			;PREVENT INTERRUPTS FROM DISTURBING
	NOP
	STAA	D,TEMPX		;LOOP COUNT
20$:	LDAA	X,0
	ANDA	I,0F		;GET 1 DEGIT
	CMPA	I,9.		;TEST IF BCD
	BLE	30$
	CLR	X,0		;RESET IT TO ZERO
30$:
	LDAA	X,0		;GET PRESENT VALUE
	ANDA	I,0F
	ABA			;DO AN ADD
	DAA			;MAKE DECIMAL
	STAA	X,0		;SAVE NEW VALUE
	TSTB			;SUBTRACTING?
	BMI	40$		;YES
	ANDA	I,10		;TEST HALF CARRY
	BEQ	60$		;DONE
	LDAB	I,1		;NOW DO CARRYS
40$:	INX			;GO TO NEXT DIGIT
	DEC	E,TEMPX		;DONE?
	BNE 	20$		;NO
60$:	CLI
	RTS			;RETURN
;
;DECREMENT COUNTER OR METER
;
DECCNT:	CMPB	I,CNTOP
	BNE	BADCNT		;ERROR
	LDAB	I,99		;DECIMAL MINUS 1
	LDX	D,POINTX	;GET INDEX
	CMPA	I,16.		;TEST IF A METER
	BGE	INCDEC		;YES, DECR A METER
	TST	X,1
	BNE	20$		;NO BORROW
	DEC	X,0		;DECR THE COUNTERS MSB
20$:	DEC	X,1		;LOW VALUE LSB
	RTS
;
;REQUEST A SOUND
;
SOUND:	PSHA			;SOUND NUMBER AND REPITITION COUNT
	LDX	I,SNDRAM	;SOUND VECTORS
	ANDA	I,1F
	JSR	INDEX		;POINT TO VECTOR
	PULA
	RORB
	RORA			;GET 6 BIT COUNT
	RORB
	RORA
	RORB
	RORA			;HIGH 3 BITS ARE IN B
	LSRA			;AND LOW 3 BITS IN HIGH 3 BITS OF A
	LSRA
30$:	INC	X,0		;INCR SOUND COUNT - INTERRUPTS ARE ON
	DECA
	BNE	30$
	RTS
	.PAGE
	.SBTTL	SKIPS
;
; TEST A COUNTER AND SKIP IF EQUAL TO VALUE
;
CNTNE:	LDAA	I,1		;GET NE FLAG
	BRA 	NEEQ
CNTEQ:	CLRA			;A=0 FLAG
NEEQ:	LDX	D,ACTCB
	LDX	X,PPC		;GET PC
	DEX
	LDX	X,0		;GET VALUE
	STX	D,POINTX	;SAVE IT
	JSR	INCRPC		;BUMP PC
	LDX	I,CNTMTR	;POINT X AT COUNTERS
	ASLB			;COUNT # TIMES 2
	PSHA			;SAVE ACCA
	TBA
	JSR	INDEX		;POINT AT COUNTERS
	PULA			;RESTORE FLAG
	LDX	X,0		;GET COUNTERS
	CPX	D,POINTX	;COMPARE VALUE
	BNE	40$		;NOT EQUAL
	TSTA
	BEQ	SKIP		;SKIP, THEY ARE EQUAL
	RTS			;ELSE DO THE NEXT INST.
40$:	TSTA
	BNE	SKIP		;SKIP THEY ARE NOT EQUAL
	RTS
;
;SKIP IF FALSE SIF
;
SIF:	BSR	LOADXA
	BGE	30$		;BYTE OPERAND
	ANDA	X,0		;TEST THE BIT
30$:	TSTA
	BEQ	SKIP
	RTS
;
;SKIP IF TRUE SIT
;
SIT:	BSR	LOADXA
	BGE	30$		;BYTE OPERAND
	ANDA	X,0		;TEST THE BIT
30$:	TSTA
	BEQ	NOSKIP		;DONT SKIP
SKIP:	INC	E,SKIPFL	;GET SKIP FLAG
NOSKIP:	RTS
;
;GET X AND A FROM DIRECT PAGE
;
LOADXA:	LDX	D,POINTX	;POINT AT THE ELEMENT
	LDAA	D,BMASK		;GET THE DATA
	CMPB	I,CNTOP		;IS THIS A COUNTER
	BNE	30$
	ORAA	X,1		;TWO BYTES PER COUNTER
30$:
	CMPB	I,BYTEOP	;GET CONDITION CODES
	RTS
	.PAGE
	.SBTTL	SETS
;
;SET FALSE SETF
;
SETF:	BSR	LOADXA		;SET UP
	SEI			;INTERRUPTS OFF
	COMA
	ANDA	X,0		;CLEAR THE BIT
	BRA	SETCOM
;
;SET TRUE SETT
;
SETT:	BSR 	LOADXA		;GET UP
SETLO:	SEI			;INTERRUPTS OFF
	NOP
	ORAA	X,0
SETCOM:	STAA	X,0		;PUT A ONE IN
	CLI			;INTERRUPTS ON
	RTS
;
; TEST AND SET A BIT - DONE IF ALREADY SET
;
LOCKO:	BSR	LOADXA
	BITA	X,0		;TEST IF TRUE
	BEQ	SETLO		;NOT ON GET IT
	JMP	DONE		;ON SO LEAVE
	.PAGE
	.SBTTL	CALL
;
;CALL A SUBROUTINE CALL
;
CALL:	LDX	D,ACTCB		;GET THIS TCB
	PSHA			;SAVE OFFSET
	PSHB
	INC	X,SP		;SOFTWARE PUSH
	LDAB	X,SP		;GET STACK POINTER
	CMPB	I,MAXSP		;TEST IF STACK OVERFLOW
	BLE	20$		;NO
	SWI			;YES - DIE QUIETLY
20$:	LDAA	X,PPC+1		;GET LOW PC
	PSHA
	LDAA	X,PPC		;GET HIGH PC
;
;MAKE X SORTA POINT INTO THE STACK
;
40$:	INX			;INCR X
	INX
	DECB
	BNE	40$		;NOT DONE
	PULB			;GET LOW PC
	STAB	X,INSTK+1	;SET LOW PC
	STAA	X,INSTK		;SET HIGH PC
	PULB
	PULA			;RESTORE OFFSET
;
;FALL INTO JMP SUBROUTINE
;
	.SBTTL	JUMP
;
;JMP UNCONDITIONAL
;A=OFFSET TO BRANCH WITHIN 2K PAGE
;B=HIGH 3 BITS OF OFFSET
;
JUMP:	LDX	D,ACTCB		;X=TCB PTR
	STAA	X,PPC+1		;SET LOW 8 BITS OF OFFSET
	LDAA	X,PPC		;HIGH PC
	ANDA	I,0F8
	ABA			;COMBINE 3 BITS
	STAA	X,PPC		;NEW PC
	RTS
	.PAGE
	.SBTTL	WAIT FOR COMPLETION
;
;WAIT FOR FALSE CONDITION
;
WAITFF:	PSHA			;SAVE SOUND #
	BSR	LOADXA		;GET DATA PTR
	CMPB	I,SNDSRC	;SOUNDS ONLY
	BEQ	30$
	SWI			;ELSE ERROR
30$:	TSTA
	BNE	40$		;DELAY
	INS			;POP GOES THE WEASEL
	RTS			;ITS DONE, CONTINUE
40$:
	LDX	D,ACTCB
	LDAB	I,SNDTCB-LINK+1
	PULA			;SND RAM PTR
	BRA	DELQIT		;QUEUE IT
				;FALL INTO DELAY ROUTINE
	.SBTTL	DELAY TASK
;
;DELAY ARG1 16 MILLISECOND PERIODS
;
DELQ:	LDX	D,ACTCB		;GET THIS TCB
	LDAB	I,DELTCB-LINK+1
DELQIT:	STAA	X,DELAY		;SET DELAY COUNTER
	LDAA	I,ACTCB-LINK+1	;THIS MAKES A QUEUE CELL LOOK LIKE A TCB
	JSR	QMOVE		;START A DELAY
	INS
	INS
	JMP	STASK		;GO START A NEW TASK
	.PAGE
	.SBTTL	LAMP MODE
;********************************
;*
;*LAMP MODE CONTROL
;*
;********************************
;
;DESCRIPTION:	THE LAMP MODE IS A VARIABLE LENGTH INSTRUCTION
;	THE FIRST ARGUMENT IS THE DELAY LENGTH
;	ARGUMENTS 0-63 TURN ON THE LAMP
;	ARGUMENTS 64-127 TURN OFF THE LAMP
;	ARGUMENTS WITH BIT 7 ON CAUSE A DELAY
;	FF TERMINATES THE INSTRUCTION
;
;REGISTERS:
;	IN:	POINTX POINTS AT THE LAMP ARRAY
;
;	OUT:	DESTROYED
;
;STACK USE:	2 EXTRA BYTES FOR SUBROUTINE CALLS
;
;BASE PAGE USE:	REGULAR TEMPORARIES
;
LAMPMD:	LDX	D,ACTCB		;X=TCB
	LDX	X,PPC		;GET INTERPRETED PC
	DEX			;GET FIRST ARGUMENT
	LDAA	X,0		;WHICH IS THE DELAY TIME
	LDX	D,ACTCB
	STAA	X,LMDEL		;SET IT INTO THE TCB
LAMPLP:	LDX	D,ACTCB
	LDX	X,PPC		;X=INTERPRETED PC
	LDAA	X,0		;A=NEXT ARGUMENT
	JSR	INCRPC		;GO TO NEXT ARG X=TCB ON RETURN
	CLR	X,LMFLG		;REMOVE DELAY FLAG
	INCA			;TEST IF ARG=FF
	BNE	20$		;NO
	RTS			;THEN DONE
20$:	DECA			;RESTORE A
	PSHA			;SAVE IT
	LSRA
	LSRA			;POINT AT THE LAMP WORD
	LSRA
	ANDA	I,7
	LDX	I,LIGHTS
	JSR	INDEX		;POINT AT IT
	PULB
	PSHB
	ANDB	I,7		;GET BIT NUMBER
	CLRA
	SEC
40$:	ROLA			;FORM A BIT MASK
	DECB
	BPL	40$
	PULB			;GET ARGUMENT
	SEI			;INTS OFF
	BITB	I,40		;ON OR OFF
	BNE	60$		;OFF
;
;TURN ON A LAMP
;
	ORAA	X,0
	STAA	X,0		;SET THE BIT
	BRA	80$
60$:	COMA
	ANDA	X,0		;REMOVE THE BIT
	STAA	X,0
80$:	CLI			;INTERRUPTS ON
	BITB	I,80		;STOP?
	BEQ	LAMPLP
;
;A LAMP MODE DELAY IS REQUESTED
;
	LDX	D,ACTCB		;TCB PTR
	LDAA	I,80		;LAMP MODE FLAG
	STAA	X,LMFLG		;SET FOR A LAMP MODE DELAY
	LDAA	X,LMDEL		;DELAY LENGTH
	JMP	DELQ		;GO DELAY
	.PAGE
	.SBTTL	DONE INSTRUCTION
;
;RETURN INSTRUCTION DONE
;
DONE:	LDX	D,ACTCB
	LDAB	X,SP		;TEST STACK POINTER
	BEQ	TTASK		;UNDERFLOW, END TASK
20$:	INX			;POINT X INTO STACK
	INX
	DECB
	BNE	20$		;NOT DONE
	LDAA	X,INSTK		;GET HIGH PC
	LDAB	X,INSTK+1	;GET LOW PC
	LDX	D,ACTCB		;X=TCB
	DEC	X,SP		;POP STACK
	STAA	X,PPC		;SET NEW PC
	STAB	X,PPC+1
	RTS
;
;TERMINATE THIS TASK, X=TCB
;
TTASK:	INS
	INS			;PURGE STACK
	LDAA	I,ACTCB-LINK+1	;OLD QUEUE
	LDAB	I,FRETCB-LINK+1	;NEW QUEUE
				;X=TCB PTR
	JSR	QMOVE		;END THIS TASK
	DEC	E,ACTTSK	;DECR ACTIVE TASKS
;
;FALL INTO STASK TO START NEW TASKS
;
	.PAGE
	.SBTTL	SCAN LOOP
;*****************************
;*
;**LOOK FOR THE NEXT SWITCH AND START A TASK
;*
;*****************************
;
;DESCRIPTION:	EVERY SWITCH CLOSURE INITIATES A TASK
;		EXCEPT IN ATTRACT MODE OR TILT MODE
;
;
;
;
;REGISTERS:	
;	IN:	NOT REQUIRED
;	OUT:	DOESN'T MATTER
;
;
;
;STACK USE:	NONE USED EXCEPT WHEN STARTING A TASK
;
;
;
;
;
;BASE PAGE USE:	SWIND		;CURRENT SWITCH INDEX
;		SWSAV		;CURRENT 8 SWITCHES
;		SWTAT		;=0 GAME MODE ELSE ATTRACT
;
;
;
;
;START NEW TASKS WHEN SWITCHES CLOSE
;
STASK:	LDAA	D,ACTTSK	;NUMBER OF ACTIVE TASKS
	CMPA	I,MAXTSK	;ALL RUNNING?
	BGE	25$		;ALL BUSY- RUN'EM
;
;FIRST CHECK SPECIAL FLAGS FOR TILT, ATTRACT, OR START
;
	SEI
	NOP
	LDAA	D,FLAGS+7	;GET OS COMMUNICATIONS WORD
	BMI	30$		;ALREADY TILTED - EXECUTE TILT ROUTINE
;
;NOT TILTED THEN, CHECK IF NOW
;
	LDAB	D,NEWSWT+TLTOFF	;TEST IF TILT IS ON
	LSRB
	BCC	30$		;NOT TILTED
	ORAA	I,BTILT		;SET TILT BIT
	STAA	D,FLAGS+7
	LDX	I,20.		;20 SOUNDS
20$:	CLR	X,SNDRAM	;ABORT ALL SOUNDS BUT TILT SOUND #0
	DEX
	BNE	20$
	JMP	START		;RESTART INTERPRETER
25$:	JMP 	GOTASK
;
;IT IS IN GAME OR ATTRACT MODE
;
30$:	CLI
	LDAB	D,SWSTAT	;TEST CURRENT GAME
	BNE	GMODE		;GAME MODE
	BITA	I,BNEXT		;IS THIS A START REQUEST?
	BEQ	AMODE		;NO - CONTINUE ATTRACT
	STAA	D,SWSTAT	;SET TO GAME MODE
	LDX	I,LIGHTS	;ZERO LAMPS
50$:	CLR 	X,0
	INX
	CPX	I,LIGHTS+8	;DONE
	BNE	50$
RESTART:SEI
	LDAA	I,80		;GET RESTART SWITCH
	ORAA	D,NEWSWT+7
	STAA	D,NEWSWT+7
	JMP	START		;START WILL ABORT TASKS, CLI
;
;IDEALLY THE FIRST 8 SWITCHES ARE ACTIVE IN ATTRACT SO THAT MULTITASKED
;ATTRACT DISPLAY IS VISABLE - BUT NO PLAYFIELD SWITCHES ARE ALLOWED.
;FOR NOW, CONTROLLED BY A TABLE
;
GMODE:	BITA	I,BATRT		;IS IT NOW ATTRACTING
	BEQ	AMODE		;NO - DO SWITCH SCAN
	CLR	E,SWSTAT	;SET ATTRACT MODE FLAG
	JMP	START		;PUNT TO START A GAME
AMODE:
	LDX	D,SWIND		;GET INDEX FOR SWITCHES
	LDAA	D,SWSAV		;GET SAVED SCAN
	BEQ	NEXTSW		;GET NEXT SWITCHES
	LDAB	I,1		;SET BIT MASK
40$:	RORA			;TEST LOW BIT
	BCS	60$		;BIT ON
	ASLB
	BRA	40$		;TEST NEXT BIT
60$:	COMB			;FORM MASK
	TBA
	ANDA	D,SWSAV		;REMOVE THIS BIT
	STAA	D,SWSAV
;DETERMINE BIT NUMBER
	CLRA
65$:	RORB			;BIT MASK IS SHIFTED
	BCC	STSTRT		;FOUND IT
	INCA			;COUNT BITS
	BRA	65$		;KEEP TRYING
STSTRT:	STX	D,TEMP		;SAVE SWITCH BYTE INDEX
	LDAB	D,TEMP+1
	ASLB
	ASLB			;TIMES 8
	ASLB
	ABA			;FORMS A VECTOR POINTER
	JSR	USTAT		;KEEP W/W STATISTICS
	ASLA
	TAB			;B=SWITCH NUMBER
	LDX	I,UVECTORS	;USERS VECTORS
	JSR	LINDEX		;GET THE TASKS PC
	STX	D,TEMP		;SAVE X
	LDX	D,FRETCB	;START A TASK - GET A TCB
	STAB	X,DELAY		;SAVE SWITCH NUMBER FOR DEBUGGING
	LDAA	D,TEMP		;SET HIGH PC
	STAA	X,PPC
	LDAA	D,TEMP+1	;SET LOW PC
	STAA	X,PPC+1
	LDAA	I,FRETCB-LINK+1	;OLD QUEUE
	LDAB	I,ACTCB-LINK+1	;NEW QUEUE
				;X=NEW TCB PTR
	JSR	QMOVE
	INC	E,ACTTSK	;COUNT OF TASKS
	BRA	GOTASK		;START THE TASK NOW
;
;READ NEXT 8 SWITCHES
;
NEXTSW:	DEX			;GO TO NEXT SWITCH
	STX	D,SWIND		;SET CONDITION CODES
	BMI	NEWSCAN		;DONE
	SEI
	NOP
	LDAB	X,NEWSWT	;READ THE SWITCHES
	LDAA	D,SWIND+1	;GET INDEX
	BNE	30$		;NOT BYTE ZERO
	TBA			;OS SWITCH BYTE
	ANDB	I,2		;USERS ONLY SWITCH
	ANDA	I,0FD
	BNE	ITOOS		;LET OS HANDLE IT
30$:	CMPA	I,6		;TILT BYTE?
	BNE	40$		;NOPE
	TBA
	ANDA	I,1		;SAVE TILT BIT
	ANDB	I,0FE		;REMOVE TILT BIT
	BRA	50$
40$:	CLRA			;CLEAR THESE SWITCHES
50$:	STAA	X,NEWSWT	;RESET DEBOUNCED LATCHES
	CLI			;REENABLE INTS
	TST	E,SWSTAT	;ATTRACT?
	BNE	70$		;NOPE
	TST	E,SWIND+1	;BYTE ZERO?
	BNE	60$		;NOPE
	CLRB			;NO ZERO BYTE SWITCHES IN ATTRACT
60$:	ANDB	I,0C0		;ATTRACT SWITCHES
70$:	TST	E,FLAGS+7	;TEST IF TILTED
	BPL	80$		;NOT TILTED
	LDAB	D,SWIND+1	;GET INDEX
	SUBB	I,6		;TEST IF TILT SWITCH BYTE
	BNE	75$		;NOPE ELSE B=0
	BITA	I,1		;IS TILT SWITCH ON?
	BEQ	75$		;NOPE
	STAB	D,NEWSWT+6	;ELSE CLEAR IT
	INCB			;B=1 WHICH IS THE TILT SWITCH
	BRA	80$		;GO DO TILT ROUTINE
75$:	CLRB			;NO SWITCHES DURING A TILT
80$:	STAB	D,SWSAV		;SAVE THE SWITCHES
	BEQ	NEXTSW		;DO NEXT SWITCHES
ISTASK:	JMP	STASK		;GO EXECUTE THE SWITCH TASK
ITOOS:	JSR	TOOS		;GO TO OPERATING SYSTEM SWITCH ROUTINE
NEWSCAN:LDAA	I,SWTCNT	;RESET SCAN INDEX
	STAA	D,SWIND+1
	CLR	E,SWIND		;INIT HIGH BYTE OF PTR
;
;NOTE:	SWSAV=0 SO NEXTSW WILL BE CALLED NEXT TIME STASK IS
;	ENTERED TO SET SWIND=SWIND-1
;
;START READY TASKS AT THE END OF A SCAN
;
GOTASK:	LDX	D,ACTCB		;IS ANYONE READY?
	BEQ	ISTASK		;NO KEEP WATCHING
	JMP	OPLOOP		;EXECUTE TASK
	.PAGE
	.SBTTL	HANDLE SOUND QUEUE
;*********************
;*
;* SNDQUE
;*
;*********************
;
;DESCRIPTION:	THIS ROUTINE IS ENTERED UNDER INTERRUPTS EVERY 8MS.
;	IF A TCB IS QUEUED, IT CHECKS TO SEE IF THE SOUND WHOSE
;	NUMBER IS KEPT IN THE DELAY BYTE OF THE TCB IS COMPLETED.  
;	IF SO, THE TCB IS READIED FOR EXECUTION.
;
;REGISTERS:
;	IN:	NONE REQUIRED
;
;	OUT:	DESTROYED
;
;STACK USE:	0 IF NO SOUNDS ARE QUEUED
;		5 BYTES IF A QUEUED TCB IS BEING READIED
;
;BASE PAGE USE:	TASKING TEMPS
;		2 BYTES OF SNDTMP
;
ISNDQUE: LDX	D,SNDTCB
	BNE	20$		;SOMETHINGS ON THE QUEUE!
10$:	RTS			;EXIT
20$:	LDAA	X,DELAY		;GET SOUND NUMBER
	LDAB	X,LINK		;NEXT TCB PTR
	STX	D,SNDTMP	;GAVE TCB PTR
	LDX	I,SNDRAM	;GET SOUND PTR
	JSR 	INDEX
	LDAA	X,0		;GET SOUND COUNTER
	BEQ	80$		;ITS DONE-READY TASK
60$:	TBA			;A=TCB LINK
	BEQ	10$		;END OF TCB QUEUE
	STAA	D,SNDTMP+1	;GUILD A NEW TCB PTR
	CLR	E,SNDTMP
	LDX	D,SNDTMP
	BRA	20$		;DO IT AGAIN
80$:	LDX	D,SNDTMP	;GET TCB PTR
	LDAA	X,LINK
	PSHA			;GAVE QUEUE LINK
	LDAA	I,SNDTCB-LINK+1	;OLD QUEUE
	LDAB	I,ACTCB-LINK+1	;NEW QUEUE
	BSR	QMOVE		;READY THE TASK
	PULB
	BRA	60$		;CONTINUE DOWN QUEUE
	.PAGE
	.SBTTL	TIMER
;*************************
;*
;* TIMER SUBROUTINE TO HANDLE
;* DELAY QUEUE
;*
;*************************
;
;DESCRIPTION:	THIS ROUTINE IS ENTERED BY A TIMER INTERRUPT EVERY 16
;		MILLISECONDS.  IT DECREMENTS ALL DELAY COUNTERS FOR TASKS
;		IN THE DELAY QUEUE.  IT ALSO READYS A TASK WHEN THE COUNT
;		BECOMES ZERO.
;
;REGISTERS:
;	IN:	NONE REQUIRED
;
;	OUT:	ALL DESTROYED
;
;STACK USE:	6 BYTES IF A TASK IS TO BE STARTED
;
;
;BASE PAGE USE:	USES ONLY THE INTERRUPT TEMPORARIES
;
;
ITIMER:	LDX	D,DELTCB	;GET DELAY QUEUE HEAD CELL
	BEQ	TIMEXIT		;LEAVE WHEN DONE
20$:	DEC	X,DELAY		;MAINTAIN THE COUNTER
	BNE	40$		;NOT DONE, CONTINUE
	LDAA	X,LINK		;GET NEXT TCB
	PSHA			;GAVE IT
	LDAA	I,DELTCB-LINK+1	;OLD QUEUE
	LDAB	I,ACTCB-LINK+1	;NEW QUEUE
				;X=CURRENT TCB
	BSR	QMOVE		;MOVE TO READY STATE
	PULA			;GET LINK
	TSTA			;SET CONDITION CODES
	BRA	50$		;CONTINUE COUNTING
40$:	LDAA	X,LINK		;GET NEXT TCB PTR
50$:	BEQ	TIMEXIT		;DONE
	SEI			;INTS OFF
	NOP
	STAA	D,TEMPX+1	;SET NEW TCB PTR
	CLR	E,TEMPX
	LDX	D,TEMPX		;X=NEXT TCB
	CLI			;INTS ON
	BRA	20$		;TIME IT
TIMEXIT:RTS
	.PAGE
	.SBTTL	QUEUE HANDLING SUBROUTINES
;
;MOVE A TCB FROM ONE QUEUE TO ANOTHER
;	OLD QUEUE   = A
;	NEW QUEUE   = B
;	TCB PTR     = X
;
QMOVE:	PSHB			;SAVE NEW QUEUE PTR
	BSR	QDELETE		;REMOVE FROM OLD QUEUE
	PULA			;GET NEW QUEUE PTR
				;X STILL=TCB PTR
				;FALL INTO QUEUE INSERT ROUTINE
;
;QUEUE TCB X=CURRENT TCB POINTER
;	   A=NEW QUEUE HEAD CELL
;
QINSERT:SEI			;INTERRUPTS OFF
	NOP
	STX	D,TEMPX2	;SAVE TCB PTR
	STAA	D,TEMPX+1
	CLR	E,TEMPX		;BUILD HEAD CELL PTR
QMLOOP:	LDX	D,TEMPX		;GET TCB
	LDAB	X,LINK		;GET NEXT LINK
	BEQ	ENDQ		;FOUND END
	STAB	D,TEMPX+1	;BUILD NEW PTR
	BRA	QMLOOP		;LOOK FOR END
ENDQ:	LDAA	D,TEMPX2+1	;GET NEW TCB PTR
	STAA	X,LINK		;LINK IN THE TCB
	LDX	D,TEMPX2	;RESTORE TCB PTR
	CLR	X,LINK		;END OF QUEUE LINK
	CLI			;ENABLE INTERRUPTS
	RTS
;
;REMOVE A TCB FROM A QUEUE
;DELETE TCB	X = CURRENT TCB PTR (PRESERVED)
;		A = CURRENT QUEUE HEAD CELL
;
QDELETE:SEI			;INTERRUPTS OFF
	NOP
	LDAB	X,LINK		;GET CURRENT NEXT LINK
	STX	D,TEMPX2	;SAVE X REGISTER
	STAA	D,TEMPX+1	;SET NEW X PTR
	CLR	E,TEMPX
10$:	LDX	D,TEMPX		;GET NEXT TCB PTR
	LDAA	X,LINK		;FIND PROCEEDING LINK
	CMPA	D,TEMPX2+1	;DOES THIS POINT TO THE TCB
	BEQ	20$		;YES, UNLINK IT
	STAA	D,TEMPX+1	;FORM NEXT POINTER
	BRA	10$
20$:	STAB	X,LINK		;BREAKS THE TCB FROM THE CHAIN
	LDX	D,TEMPX2	;RESTORE X REGISTER
	CLI			;INTERRUPTS ON!
	RTS
;
;ENTRY VECTORS FOR LINKAGE WITH OPERATING SYSTEM
;
START	=ISTART
TIMER	=ITIMER
SNDQUE	=ISNDQUE
MINC	=IMINC
SCRE	=ISCRE
	.END
                                                                                                                                                                                          